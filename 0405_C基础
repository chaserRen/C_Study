0405
B站连接  https://www.bilibili.com/video/BV1RW411G7cr?p=2&vd_source=0bda11ae177201453a1ae118926700c3
1 C语言编译gcc
1.1 gcc概述
我自己安装的VM  用户名：chirs  密码：chris
GUN C Compiler 开源社区 G开源社区，翻译C语言，后续还能翻译更多的语言，相当于一个翻译组织，将计算机语言翻译成计算机语言（计算机智能理解01高低电平）
常用gcc指令：
gcc -o  o表示output  e.g. gcc -o build main.c
gcc -v  v表示版本，查询目前linux是否可用gcc
gcc -v -o source_file target_file 习惯性是先-v等操作，最后-o接文件名

1.2 C语言的编译过程
预处理 => 编译 => 汇编 => 连接
预处理内容：去掉注释，加载头文件，替换宏定义，不会进行语法检查 define 和 include不是关键字
过程：gcc先生成.s文件 gcc -S => 进行汇编 gcc -c 将.s生成.o => 连接器【gcc是一个翻译器集合，调用了不同的工具进行翻译】 .s文件是汇编语言，.o文件是二进制文件

1.3 C语言常见错误
预处理错误：
   include 后续有两种 
      #include "" 通常这个是自己写的头文件，从当前目录找文件，不在当前目录会找不到.h文件，如果在工程里添加到头文件内，在win下还在同一个目录任然可以找到改头文件，但是不合适，可以gcc -I— h文件路径，或者在“”内添加路径
      #include <> 通常这个是系统的头文件

函数未定义错误:
  void fun（void）仅仅只是声明，没有实现具体函数，在int main（）内调用该函数会报未定义错误

1.4 预处理使用
#include 包含头文件，通过gcc对这些头文件也进步编译
#define 宏 相当于替换作用， 实例： #define 宏名 宏体   不进行语法检测，为了避免错误，可采用加括号的方式，例如#define ABC (5+3)  宏函数#define ABC(x) 5+(x)
预定义宏，系统已经编译好的宏，__XXX__ printf("fun %s, %s, %f\n", __FUNCTION__, __FILE__, __LINE__); 这句话作用通常在工程中多个文件一起执行，如果出现问题，可以确定文件信息，快速定位问题
#ifdef #else #endif 条件编译 工程应用中经常使用  
  #ifdef ABC
      条件内容，意思是如果先宏定义ABD后才会执行这段内容，否则就不执行，方便调试
  #endif
编译时采用 gcc -DABC -o build main.c == #define ABC
宏展开 # ##

2 C语言常用关键字和运算
核心：什么场景用，怎么用（关键字的用法），为什么这么用(C语言关键设计初衷)

2.1 关键字
一共有32个关键字，例如int、float、struct、enum、return、sizeof等。
sizeof()不是函数，%d有些情况会出错，一般用%lu 表示无符号变量
嵌入式开发中关键字的意义：
C操作对象：资源/内存，例如：LCD缓存、LED灯
资源都会有属性，比如大小地址，关键字来定义变量是，可以理解为限制了内存，例如LED灯引脚设置为int a，通过int关键字已经限制了最大内存

2.1.1 标准数据类型
（1）char 
大小：char 8bit 1个字节（硬件中不考虑字节，考虑bit）
数据类型的产生原因：硬件芯片操作最小单位是0/1，这是bit
应用场景：描述硬件的最小的单位，数据不会溢出，又可以节省内存，例如ASCII码表表示每个键位都可以用一个8bit（1字节）的组合表示

（2）int
大小：2或4字节，按照编译器决定
char a=300；此时会溢出，因为char最多8bit=256
编译器有一个最优处理大小，系统一个周期所能接收的最大处理单位，例如32bit的系统，表示计算机一个周期能处理的信息是32bit，
16bit=2字节，32bit=4字节，所以一个32bit计算器或者16bit单片机都可以处理int，
这两种情况下int的大小不相同，由具体是哪种编译器来决定。

（3）整形常量
char a = 300L； 计算器翻译时，按照char给a分配8bit，L表示一个比较大的书
例如：16bit（2B）的计算器，每次分配2字节，max是65535，如果要定义int66535>65535，2字节不够需要4个字节，
在这个计算器下定义int a=66535L; 分配4个字节，表示可以存一个较大的数。
嵌入式进制

（4） 特殊长度限制符
Long、short

（5）unsigned signed
无符号：数据，比如传感器采集的数据
有符号：数字，进行具体运算

区别，char a=-1； unsigned char a=-1； a>>1，无符号右移最终会移到全0

（6）float、double
大小：float 4B  double 8B
同一个数值浮点数和int存储内容不一样

（7）void
通常用于占位，

2.1.2 自定义数据类型
C语言默认的数据类型不够用，所以可以自定义数据类型
（1）struct 结构体
作用：可以理解为各种元素的组合，存储相同类型的数据项
使用场景举例：通常寄存器里，有好几个寄存器地址，四个寄存器一起用，
每个寄存器地址都是4bit，需要把四个寄存器组合在一起一起用。
struct声明：
struct tag { 
    member-list
    member-list 
    member-list  
    ...
} variable-list ;

struct定义：
struct tag tag_name；

struct内部定义顺序也有影响，连续的存储空间

（2）union 共用体
作用：公用起始地址，不用于描述具体的物理地址，char a; int b;修改了b，a的开始4bit也跟随b一起改变。

（3）enum 枚举
被命名的整形常数集合
格式：
enum　枚举名　{枚举元素1,枚举元素2,……};
实例：
enum DAY
{
      MON=1, TUE, WED, THU, FRI, SAT, SUN
};
第一个枚举成员的默认值为整型的 0，后续枚举成员的值在前一个成员上加 1。
如果把第一个枚举成员的值定义为 1，第二个就为 2，以此类推。
enum season {spring, summer=3, autumn, winter};
在这个实例中，spring 的值为 0，summer 的值为 3，autumn 的值为 4，winter 的值为 5

定义：（三种方式）
enum DAY{M, W, T, W, F, S, S}; enum DAY day; 先定义枚举类型名称为DAY，再定义一个DAY类型枚举变量，该枚举变量叫day
enum DAY{M, W, T, W, F, S, S}day;            在定义枚举类型时同时顶一个枚举变量叫做day
enum {M, W, T, W, F, S, S}day;               不定义枚举名称，然后直接定义变量名

调用：
enum {M, W, T, W, F, S, S}day; 
day = F
此时day变量为Friday，输出%d输出的值为数值

枚举数值不连续不发遍历。

（4）typdef

2.1.3 逻辑结构

2.1.4 类型修饰符
定义C语言中变量/函数的存储位置、生命周期和作用域。
对内存资源存放位置的限定，比如char变量要存放在栈或者寄存器中，不同位置的资源有的可读，有的不可写，
比如开机的动画，会存在一定的位置，有存放条件
（1）auto
作用：分配一个可读可写的区域，几乎是所有局部变量默认的存储类

（2）register
作用：存储在寄存器中而不是RAM（）中的局部变量
补充：内存通常是存储器，CPU会把内存中的数据取出来放在CPU内的寄存器进行处理，CPU内部处理速度快，
在内存中处理速度慢。
使用场景：对于一些需要经常访问的变量，需要快读读取，可以放在寄存器上，编译器会尽量安排CPU
的寄存器去存放这个变量，如果CPU内寄存器不足时，还放在普通存储器上。
对register变量无法无地址，&符号没用

（3）static
作用：静态变量
应用场景：（主要有三个）
修饰三种数据：
1）函数内部变量
2）函数外部全局变量
3）函数本上定义为变量 

（4）extern
作用：外部声明

（5）const
常量定义，定义一个不能修改的常量，

（6）volatile
告知编译器编译方法的关键字，不优化编译

2.1.5 杂项
return void

2.2 运算符
包括：算术操作运算、逻辑运算、位运算、赋值运算、内存访问运算，重点是位运算。
位运算：
左移：移n位，乘以2^n
右移：移n位，除以2^n，正数左侧补0，负数左侧补1
与&：相当于取数，或清零器（屏蔽低八位）  设置某一个资源第五位为低电平， a = a & ~(0x1<<5) 以此类推，对某一位进行清零 a = a & (~(0x1<<n))
或|：保留作用，相当于设置器。设置某一个资源第五位为高电平，a = a |(0x1<<5) 以此类推，对某一位进行置位 a = a |(0x1<<n)
异或^: 交换两个变量

2.3 逻辑操作
顺序执行、分支执行、循环执行






